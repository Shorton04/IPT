*&---------------------------------------------------------------------*
*& Include          ZIN_CMX_WORKORDER_F01
*&---------------------------------------------------------------------*

*---------------------------------------------------------------------*
* Fetch candidate orders
*---------------------------------------------------------------------*
FORM f_get_orders.

  SELECT SINGLE atinn
    INTO @gv_atinn
    FROM cabn
    WHERE atnam = 'INTERFACE'.

  IF sy-subrc <> 0.
    MESSAGE 'Characteristic INTERFACE not found' TYPE 'E'.
  ENDIF.

  IF so_date-low IS INITIAL OR so_time-low IS INITIAL.
    MESSAGE 'Check from Date and Time are mandatory' TYPE 'E'.
  ENDIF.

  " Eligible orders (IDAT1 not blank OR IDAT2 >= check date)
  SELECT *
    FROM viaufkst
    WHERE auart IN @so_auart
      AND iwerk IN @so_werks
      AND aufnr IN @so_aufnr
      AND ( idat1 IS NOT INITIAL OR idat2 >= @so_date-low )
    INTO TABLE @gt_orders.

ENDFORM.

*---------------------------------------------------------------------*
* Prefetch related master data
*---------------------------------------------------------------------*
FORM f_prefetch_data.

  IF gt_orders IS INITIAL.
    RETURN.
  ENDIF.

  DATA: lt_objek      TYPE TABLE OF inob-objek,
        lt_objnr      TYPE TABLE OF jest-objnr,
        lt_objectid   TYPE TABLE OF cdhdr-objectid,
        lt_cuobj      TYPE TABLE OF inob-cuobj,
        lt_ausp_objek TYPE TABLE OF ausp-objek,
        lv_objid      TYPE cdhdr-objectid.

  LOOP AT gt_orders INTO gs_order.
    IF gs_order-equnr IS NOT INITIAL.
      APPEND gs_order-equnr TO lt_objek.
    ENDIF.

    IF gs_order-tplnr IS NOT INITIAL.
      APPEND gs_order-tplnr TO lt_objek.
    ENDIF.

    APPEND gs_order-objnr TO lt_objnr.

    CONCATENATE sy-mandt '30' gs_order-aufnr INTO lv_objid.
    APPEND lv_objid TO lt_objectid.
  ENDLOOP.

  SORT lt_objek.     DELETE ADJACENT DUPLICATES FROM lt_objek.
  SORT lt_objnr.     DELETE ADJACENT DUPLICATES FROM lt_objnr.
  SORT lt_objectid.  DELETE ADJACENT DUPLICATES FROM lt_objectid.

  IF lt_objnr IS NOT INITIAL.
    SELECT objnr, stat, inact
      FROM jest
      INTO TABLE @gt_jest
      FOR ALL ENTRIES IN @lt_objnr
      WHERE objnr = @lt_objnr-table_line.
  ENDIF.

  IF lt_objek IS NOT INITIAL.
    SELECT objek, cuobj
      FROM inob
      INTO TABLE @gt_inob
      FOR ALL ENTRIES IN @lt_objek
      WHERE objek = @lt_objek-table_line.
  ENDIF.

  IF gt_inob IS NOT INITIAL.
    LOOP AT gt_inob INTO gs_inob.
      APPEND gs_inob-cuobj TO lt_cuobj.
    ENDLOOP.
    SORT lt_cuobj. DELETE ADJACENT DUPLICATES FROM lt_cuobj.

    LOOP AT lt_cuobj INTO DATA(lv_cuobj).
      DATA(lv_ausp_objek) = lv_cuobj.
      APPEND lv_ausp_objek TO lt_ausp_objek.
    ENDLOOP.

    IF lt_ausp_objek IS NOT INITIAL.
      SELECT objek, atinn, atwrt
        FROM ausp
        INTO TABLE @gt_ausp
        FOR ALL ENTRIES IN @lt_ausp_objek
        WHERE objek = @lt_ausp_objek-table_line.
    ENDIF.
  ENDIF.

  IF lt_objectid IS NOT INITIAL.
    SELECT objectid, udate, utime
      FROM cdhdr
      INTO TABLE @gt_cdhdr
      FOR ALL ENTRIES IN @lt_objectid
      WHERE objectclas = 'ORDER'
        AND objectid   = @lt_objectid-table_line.
  ENDIF.

ENDFORM.


*---------------------------------------------------------------------*
* Process fetched orders
*---------------------------------------------------------------------*
FORM f_process_orders.

  LOOP AT gt_orders INTO gs_order.
    PERFORM f_check_status USING gs_order.
  ENDLOOP.

ENDFORM.

*---------------------------------------------------------------------*
* Check status
*---------------------------------------------------------------------*
FORM f_check_status USING ps_order TYPE viaufkst.

  DATA: lv_obj            TYPE cuobj,
        lv_value          TYPE atwrt,
        lv_stat           TYPE jest-stat,
        lv_date           TYPE udate,
        lv_time           TYPE utime,
        lv_objid          TYPE c LENGTH 20,
        lv_inact          TYPE jest-inact,
        lv_vornr          TYPE vornr,
        lv_rel_active     TYPE abap_bool VALUE abap_false,
        lv_teco_active    TYPE abap_bool VALUE abap_false,
        lv_cmx_active     TYPE abap_bool VALUE abap_false,
        lv_cmxs_active    TYPE abap_bool VALUE abap_false,
        lv_locked_active  TYPE abap_bool VALUE abap_false,
        lv_cmxs_date      TYPE jcds-udate,
        lv_cmxs_time      TYPE jcds-utime,
        lv_change_date    TYPE cdhdr-udate,
        lv_change_time    TYPE cdhdr-utime,
        lv_has_new_change TYPE abap_bool VALUE abap_false,
        lv_cmxs_datetime  TYPE timestamp,
        lv_change_datetime TYPE timestamp.

  "---------------------------------------------------
  " Classification object (equipment or functional location)
  "---------------------------------------------------
  IF ps_order-equnr IS NOT INITIAL.
    SELECT SINGLE cuobj INTO lv_obj FROM inob WHERE objek = ps_order-equnr.
  ELSE.
    SELECT SINGLE cuobj INTO lv_obj FROM inob WHERE objek = ps_order-tplnr.
  ENDIF.

  IF lv_obj IS INITIAL.
    RETURN.
  ENDIF.

  "---------------------------------------------------
  " Step 1: Check REL and TECO
  "---------------------------------------------------
  SELECT SINGLE stat FROM jest INTO lv_stat
   WHERE objnr = ps_order-objnr AND stat = 'I0002' AND inact = ''.
  IF sy-subrc = 0. lv_rel_active = abap_true. ENDIF.

  SELECT SINGLE stat FROM jest INTO lv_stat
   WHERE objnr = ps_order-objnr AND stat = 'I0045' AND inact = ''.
  IF sy-subrc = 0. lv_teco_active = abap_true. ENDIF.

  IF lv_rel_active = abap_false AND lv_teco_active = abap_false.
    RETURN. " Not eligible
  ENDIF.

  "---------------------------------------------------
  " Step 2: Check CMXC (Confirmed)
  "---------------------------------------------------
  SELECT SINGLE inact FROM jest INTO lv_inact
   WHERE objnr = ps_order-objnr AND stat = 'E0010'.
  IF sy-subrc = 0 AND lv_inact IS INITIAL.
    lv_cmx_active = abap_true.
  ENDIF.

  IF lv_cmx_active = abap_true AND lv_teco_active = abap_false.
    RETURN.
  ENDIF.

  "---------------------------------------------------
  " Step 3: INTERFACE must be CMX
  "---------------------------------------------------
  SELECT SINGLE atwrt INTO lv_value
    FROM ausp
   WHERE objek = lv_obj AND atinn = gv_atinn.
  IF sy-subrc <> 0 OR lv_value <> 'CMX'.
    RETURN.
  ENDIF.

  "---------------------------------------------------
  " Step 4: Detect CMXS (Sent to CMX) - USE JCDS NOT JEST
  "---------------------------------------------------
  SELECT MAX( udate ) AS max_date
         MAX( utime ) AS max_time
    INTO (lv_cmxs_date, lv_cmxs_time)
    FROM jcds
   WHERE objnr = ps_order-objnr
     AND stat  = 'E0014'
     AND inact = ''.

  IF sy-subrc = 0 AND lv_cmxs_date IS NOT INITIAL.
    lv_cmxs_active = abap_true.
  ENDIF.

  "---------------------------------------------------
  " Step 5: Get latest ORDER change timestamp (CDHDR)
  "---------------------------------------------------
  CONCATENATE sy-mandt '30' ps_order-aufnr INTO lv_objid.
  
  SELECT MAX( udate ) AS max_date
         MAX( utime ) AS max_time
    INTO (lv_change_date, lv_change_time)
    FROM cdhdr
   WHERE objectclas = 'ORDER' 
     AND objectid = lv_objid.

  "---------------------------------------------------
  " Step 6: Determine if order has newer change since CMXS
  "---------------------------------------------------
  IF lv_cmxs_active = abap_true.
    " Convert to timestamps for accurate comparison
    CALL FUNCTION 'SALP_SM_CALC_TIME_DIFFERENCE'
      EXPORTING
        date_1  = lv_cmxs_date
        time_1  = lv_cmxs_time
        date_2  = '19000101'
        time_2  = '000000'
      IMPORTING
        seconds = lv_cmxs_datetime.

    CALL FUNCTION 'SALP_SM_CALC_TIME_DIFFERENCE'
      EXPORTING
        date_1  = lv_change_date
        time_1  = lv_change_time
        date_2  = '19000101'
        time_2  = '000000'
      IMPORTING
        seconds = lv_change_datetime.

    IF lv_change_datetime > lv_cmxs_datetime.
      lv_has_new_change = abap_true.
    ELSE.
      lv_has_new_change = abap_false.
    ENDIF.
  ELSE.
    " No CMXS yet - this is a new order
    lv_has_new_change = abap_true.
  ENDIF.

  "---------------------------------------------------
  " Step 7: Check lock status (I0043)
  "---------------------------------------------------
  SELECT SINGLE inact FROM jest INTO lv_inact
   WHERE objnr = ps_order-objnr AND stat = 'I0043'.
  IF sy-subrc = 0.
    IF lv_inact IS INITIAL.
      lv_locked_active = abap_true.
    ELSE.
      lv_locked_active = abap_false.
    ENDIF.
  ENDIF.

  "---------------------------------------------------
  " Step 8: CRITICAL FILTER - Skip unchanged REL + CMXS orders
  "---------------------------------------------------
  " Skip if: REL, CMXS exists, no changes, not locked, not TECO
  IF lv_teco_active = abap_false
     AND lv_locked_active = abap_false
     AND lv_cmxs_active = abap_true
     AND lv_has_new_change = abap_false.
    RETURN. " ✅ Already sent, unchanged → SKIP (don't show in ALV)
  ENDIF.

  "---------------------------------------------------
  " Step 9: Set message reason (for debugging)
  "---------------------------------------------------
  IF lv_cmxs_active = abap_false.
    gs_output-msg = 'New REL (no CMXS) – create in CMX'.
  ELSEIF lv_teco_active = abap_true.
    gs_output-msg = 'TECO – send to CMX'.
  ELSEIF lv_locked_active = abap_true AND lv_has_new_change = abap_true.
    gs_output-msg = 'LKD after CMXS – resend'.
  ELSEIF lv_locked_active = abap_false AND lv_has_new_change = abap_true.
    gs_output-msg = 'Changed/unlocked after CMXS – resend'.
  ELSE.
    gs_output-msg = 'Send to CMX'.
  ENDIF.

  "---------------------------------------------------
  " Step 10: Get first valid operation
  "---------------------------------------------------
  PERFORM f_get_operation USING ps_order CHANGING lv_vornr.

  "---------------------------------------------------
  " Step 11: Prepare output
  "---------------------------------------------------
  IF lv_locked_active = abap_true.
    lv_stat = 'I0043'. " Locked
  ELSEIF lv_teco_active = abap_true.
    lv_stat = 'I0045'. " TECO
  ELSE.
    lv_stat = 'I0002'. " REL
  ENDIF.

  PERFORM f_prepare_output USING ps_order lv_vornr lv_stat.

ENDFORM.

*---------------------------------------------------------------------*
* Get first operation
*---------------------------------------------------------------------*
FORM f_get_operation USING ps_order TYPE viaufkst
                     CHANGING pv_vornr TYPE afvc-vornr.

  DATA: lv_aufpl TYPE afko-aufpl,
        lv_stat  TYPE jest-stat,
        pv_found TYPE abap_bool VALUE abap_false.

  TYPES: BEGIN OF ty_op,
           vornr TYPE afvc-vornr,
           objnr TYPE afvc-objnr,
         END OF ty_op.

  DATA: ls_op  TYPE ty_op,
        lt_ops TYPE TABLE OF ty_op.

  CLEAR pv_vornr.

  SELECT SINGLE aufpl
    INTO @lv_aufpl
    FROM afko
   WHERE aufnr = @ps_order-aufnr.

  IF sy-subrc <> 0 OR lv_aufpl IS INITIAL.
    RETURN.
  ENDIF.

  SELECT vornr, objnr
    FROM afvc
    WHERE aufpl = @lv_aufpl
    ORDER BY aplzl
    INTO TABLE @lt_ops.

  IF lt_ops IS INITIAL.
    RETURN.
  ENDIF.

  LOOP AT lt_ops INTO ls_op.
    SELECT SINGLE stat
      FROM jest
     WHERE objnr = @ls_op-objnr
       AND stat  = 'I0013'
       AND inact = ''
     INTO @lv_stat.

    IF sy-subrc <> 0.
      pv_vornr = ls_op-vornr.
      pv_found = abap_true.
      EXIT.
    ENDIF.
  ENDLOOP.

  IF pv_found = abap_false.
    pv_vornr = ''.
  ENDIF.

ENDFORM.

*---------------------------------------------------------------------*
* Prepare output
*---------------------------------------------------------------------*
FORM f_prepare_output USING ps_order TYPE viaufkst
                            pv_vornr TYPE vornr
                            pv_stat  TYPE jest-stat.

  CLEAR gs_output.

  gs_output-OrderMessageStatus        = 'CREATE'.
  gs_output-Plant                     = ps_order-iwerk.
  gs_output-MaintenanceOrder          = ps_order-aufnr.
  gs_output-MaintenanceOrderOperation = pv_vornr.
  gs_output-MaintOrdBasicStartDate    = ps_order-gstrp.
  gs_output-MaintOrdBasicEndDate      = ps_order-gltrp.
  gs_output-LatestAcceptableComplDate = ps_order-lacd_date.
  gs_output-SystemId                  = sy-sysid.

  "---------------------------------------------------
  " Determine final system status text
  "---------------------------------------------------
  SELECT SINGLE txt04
    INTO gs_output-SystemStatusText
    FROM tj02t
   WHERE istat = pv_stat
     AND spras = 'E'.

  "---------------------------------------------------
  " Technical object (Equipment or Functional Location)
  "---------------------------------------------------
  IF ps_order-equnr IS NOT INITIAL.
    gs_output-TechnicalObject = ps_order-equnr.
  ELSE.
    gs_output-TechnicalObject = ps_order-tplnr.
  ENDIF.

  APPEND gs_output TO gt_output.

ENDFORM.


*---------------------------------------------------------------------*
* Update SAP status and refresh CMXS timestamp
*---------------------------------------------------------------------*
FORM f_send_cmx.

  DATA lv_mode TYPE char10.

  IF p_test = abap_true.
    lv_mode = 'TEST'.
  ELSE.
    lv_mode = 'LIVE'.
  ENDIF.

  LOOP AT gt_output ASSIGNING FIELD-SYMBOL(<ls_output_row>).

    " Test mode: only simulate
    IF lv_mode = 'TEST'.
      CONCATENATE '[Test Mode] Would set CMXS for order'
                  <ls_output_row>-MaintenanceOrder
             INTO <ls_output_row>-msg SEPARATED BY space.
      PERFORM f_write_log USING <ls_output_row>-MaintenanceOrder
                                 <ls_output_row>-MaintenanceOrderOperation
                                 <ls_output_row>-Plant
                                 'CMXS'
                                 <ls_output_row>-msg.
      CONTINUE.
    ENDIF.

    "---------------------------------------------------
    " Live update: Toggle CMXS to force new timestamp
    "---------------------------------------------------
    DATA: lt_header   TYPE TABLE OF bapi_alm_order_headers_i,
          lt_status   TYPE TABLE OF bapi_alm_order_usrstat,
          lt_methods  TYPE TABLE OF bapi_alm_order_method,
          lt_return   TYPE TABLE OF bapiret2,
          ls_return   TYPE bapiret2,
          lv_objnr    TYPE aufk-objnr,
          lv_new_date TYPE jcds-udate,
          lv_new_time TYPE jcds-utime.

    CLEAR: lt_header, lt_status, lt_methods, lt_return,
           ls_return, lv_objnr, lv_new_date, lv_new_time.

    " Step 1: Remove CMXS
    APPEND VALUE #( orderid = <ls_output_row>-MaintenanceOrder ) TO lt_header.
    APPEND VALUE #( user_st_text = 'CMXS' langu = sy-langu activate = '' ) TO lt_status.

    APPEND VALUE #( refnumber = '00001' objecttype = 'HEADER' method = 'CHANGE'
                    objectkey = <ls_output_row>-MaintenanceOrder ) TO lt_methods.
    APPEND VALUE #( refnumber = '00002' objecttype = 'USERSTATUS' method = 'CHANGE'
                    objectkey = <ls_output_row>-MaintenanceOrder ) TO lt_methods.
    APPEND VALUE #( refnumber = '00003' objecttype = 'ORDER' method = 'SAVE'
                    objectkey = <ls_output_row>-MaintenanceOrder ) TO lt_methods.

    CALL FUNCTION 'BAPI_ALM_ORDER_MAINTAIN'
      TABLES
        it_header     = lt_header
        it_methods    = lt_methods
        it_userstatus = lt_status
        return        = lt_return.

    READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
    IF sy-subrc = 0.
      <ls_output_row>-msg = ls_return-message(72).
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
      PERFORM f_write_log USING <ls_output_row>-MaintenanceOrder
                                 <ls_output_row>-MaintenanceOrderOperation
                                 <ls_output_row>-Plant
                                 'CMXS'
                                 <ls_output_row>-msg.
      CONTINUE.
    ELSE.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT' EXPORTING wait = 'X'.
    ENDIF.

    " Step 2: Re-apply CMXS (creates new timestamp)
    CLEAR: lt_status, lt_methods, lt_return.

    APPEND VALUE #( user_st_text = 'CMXS' langu = sy-langu activate = 'X' ) TO lt_status.

    APPEND VALUE #( refnumber = '00001' objecttype = 'HEADER' method = 'CHANGE'
                    objectkey = <ls_output_row>-MaintenanceOrder ) TO lt_methods.
    APPEND VALUE #( refnumber = '00002' objecttype = 'USERSTATUS' method = 'CHANGE'
                    objectkey = <ls_output_row>-MaintenanceOrder ) TO lt_methods.
    APPEND VALUE #( refnumber = '00003' objecttype = 'ORDER' method = 'SAVE'
                    objectkey = <ls_output_row>-MaintenanceOrder ) TO lt_methods.

    CALL FUNCTION 'BAPI_ALM_ORDER_MAINTAIN'
      TABLES
        it_header     = lt_header
        it_methods    = lt_methods
        it_userstatus = lt_status
        return        = lt_return.

    READ TABLE lt_return INTO ls_return WITH KEY type = 'E'.
    IF sy-subrc = 0.
      <ls_output_row>-msg = ls_return-message(72).
      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.
    ELSE.
      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT' EXPORTING wait = 'X'.

      "---------------------------------------------------
      " Verify new CMXS timestamp (JCDS)
      "---------------------------------------------------
      SELECT SINGLE objnr INTO lv_objnr FROM aufk
       WHERE aufnr = <ls_output_row>-MaintenanceOrder.

      IF sy-subrc = 0.
        SELECT MAX( udate ) AS max_date
               MAX( utime ) AS max_time
          INTO (lv_new_date, lv_new_time)
          FROM jcds
         WHERE objnr = lv_objnr
           AND stat  = 'E0014'
           AND inact = ''.

        IF sy-subrc = 0.
          CONCATENATE 'CMXS refreshed:' lv_new_date lv_new_time
            INTO <ls_output_row>-msg SEPARATED BY space.
        ELSE.
          <ls_output_row>-msg = 'CMXS updated successfully'.
        ENDIF.
      ELSE.
        <ls_output_row>-msg = 'CMXS updated (verify manually)'.
      ENDIF.
    ENDIF.

    PERFORM f_write_log USING <ls_output_row>-MaintenanceOrder
                               <ls_output_row>-MaintenanceOrderOperation
                               <ls_output_row>-Plant
                               'CMXS'
                               <ls_output_row>-msg.

  ENDLOOP.

  COMMIT WORK.

ENDFORM.